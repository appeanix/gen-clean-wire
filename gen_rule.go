package main

import (
	"fmt"
	"go/types"
	"strings"
)

type RuleFieldMeta struct {
	Field string
	Value string
}

type RuleMeta struct {
	Name   string
	Fields []RuleFieldMeta
}

var ruleTemplate = `
// Code generated by generator, DO NOT EDIT.
package wire

import (
	rule "{{.Project}}/domain/rule"
	handler "{{.Project}}/internal/handler"
{{- if .ORM }}
	. "{{.Project}}/domain"
	dborm "{{.Project}}/internal/dborm"
	pingorm "github.com/appeanix/pingorm"
{{- end}}
)

{{ if .ORM }}
func newCruder(appDB *dborm.DB, model interface{}) *dborm.Cruder {
	return &dborm.Cruder{
		AppDB: appDB,
		Repo:  pingorm.Repo{Model: model},
	}
}
{{ end }}


{{ range .Rules }}
func new{{.Name}}(appDB *dborm.DB, context *handler.AppContext) rule.{{ .Name }} {
	return rule.{{ .Name }} {
{{- range .Fields }}
		{{.Field }}: {{ .Value }},
{{- end }}
	}
}
{{ end }}
`

const (
	entityAdapterSuffix = "EntityAdapter"
	adapterSuffix       = "Adapter"
)

func genRules() {
	// Inspect package and use type checker to infer imported types
	pkg := loadPackage("")

	// Lookup the given source type name in the package declarations
	for _, ruleName := range pkg.Types.Scope().Names() {
		// Assert suffix 'Rule'
		if !strings.HasSuffix(ruleName, "Rule") {
			continue
		}

		obj := pkg.Types.Scope().Lookup(ruleName)

		// Assert a declare type
		if _, ok := obj.(*types.TypeName); !ok {
			continue
		}

		// Assert exportable type
		if !obj.Exported() {
			continue
		}

		// Assert underlying type to be a struct
		ruleStruct, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			continue
		}

		// Build Rule instance and binding
		rule := RuleMeta{
			Name: ruleName,
		}

		for i := 0; i < ruleStruct.NumFields(); i++ {
			fieldName := ruleStruct.Field(i).Name()

			if strings.HasSuffix(fieldName, entityAdapterSuffix) {
				entityModelType := strings.Replace(fieldName, entityAdapterSuffix, "", 1)
				rule.Fields = append(rule.Fields, RuleFieldMeta{
					Field: fieldName,
					Value: fmt.Sprintf("newCruder(appDB, %s{})", entityModelType),
				})
				meta.ORM = true

			} else if strings.HasSuffix(fieldName, adapterSuffix) {
				// write custom wire extension function
				rule.Fields = append(rule.Fields, RuleFieldMeta{
					Field: fieldName,
					Value: fmt.Sprintf("new%s%s(context)", ruleName, fieldName),
				})
			}
		}
		//
		meta.Rules = append(meta.Rules, rule)
	}
}
